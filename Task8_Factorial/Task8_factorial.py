# !/usr/bin/env python
# -- coding: utf-8 --
"""
@Filename:   Task8_factorial.py
@Date:       02.08.2024
@Time:       20:40
@Author:     Mentor
@Software:   PyCharm
"""

"""
Справка!
Факториал — это произведение всех натуральных чисел от 1 до данного числа. 

Задача:
Напишите функцию factorial_func(number), принимающую в качестве параметра
целое число 0 <= n <= 100 и возвращающую факториал для этого числа.

Пример:
number = 3; factorial_func = 6;    (1 * 2 * 3)
number = 7; factorial_func = 5040; (1 * 2 * 3 * 4 * 5 * 6 * 7)
number = 16; factorial_func = 20922789888000 (1 * 2 * ... * 16)
"""
# Импортируем декоратор для кэширования значений
from functools import lru_cache

# Импортируем библиотеку случайных чисел
import random

def factorial_cycle_func(number = random.randint(2, 100)):
    """
    1 метод.
    Пример вычисления факториала при помощи цикла.

    Входное значение:
        1. number - произвольное число (int)
        Если число не будет введено с клавиатуры, берется случайное знач.
        2. factorial - начальное значение.
        Для корректной обработки задаем значение, равное 1
    Выходное значение:
        factorial - произведение всех чисел от 1 до задан числа number (int)
    """

    # Изначально определяем значение переменной равное 1
    factorial = 1

    # Производим перебор значений в цикле от 1 до заданного числа:
    for i in range(1, number + 1):
        # Факториал вычисляется, как произведение всех чисел в цикле
        factorial = factorial * i

    # Результат функции - факториал
    return factorial

@lru_cache(maxsize = 1000)
def factorial_recursive_func(number = random.randint(2, 100)):
    """
    2 метод.
    Пример вычисления факториала при помощи рекурсивной функции.
    Фактически также осуществляется перебор всех значений от заданного
    числа number до 1 с их перемножением.

    Входное значение:
        1. number - произвольное число (int)
        Если число не будет введено с клавиатуры, берется случайное знач.
        2. factorial - начальное значение.
        Для корректной обработки задаем значение, равное 1
    Выходное значение:
        factorial - произведение всех чисел от 1 до задан числа number (int)
    """

    # Если число меньше 2, то возвращаем 1
    if number < 2:
        return 1
    # Во всех других случаях вычисляем факториал при помощи рекурсии
    elif number >= 2:
        return number * factorial_recursive_func(number - 1)

def factorial_memoize_func(number = random.randint(2, 100)):
    """
    3 метод.
    Пример вычисления факториала при помощи мемоизации.

    Справка!
    Мемоизация - это метод, используемый для хранения результатов
    предыдущих вызовов функций для ускорения будущих вычислений.

    Входное значение:
        1. number - произвольное число (int)
        Если число не будет введено с клавиатуры, берется случайное знач.
        2. factorial - начальное значение.
        Для корректной обработки задаем значение, равное 1
    Выходное значение:
        factorial - произведение всех чисел от 1 до задан числа number (int)
    """

    # Задаем пустой словарь для хранения вхождений факториала
    factorial_dict = {}

    # Если число меньше 2, то возвращаем 1
    if number < 2:
        return 1
    # Если число не входит в заданный словарь,
    # вычисляем значение факториала и заносим значение в словарь
    if number not in factorial_dict:
        factorial_dict[number] = number * factorial_memoize_func(number - 1)

        # Результат работы функции - значение факториала, записанное в словаре
        return factorial_dict[number]


if __name__ == '__main__':
    # Блок работы программы с пользовательскими данными
    try:
        my_number = int(input('\nВведите число, '
                            'факториал которого хотите получить:\n\t'))

        # Запуск функции с пользовательскими данными
        ### 1 метод. Использование цикла ###
        print(f'{my_number}! ='
            f' {factorial_cycle_func(my_number)}')

        ### 2 метод. Использование рекурсивной функции ###
        print(f'{my_number}! =  {factorial_recursive_func(my_number)}')

        ### 3 метод. Использование мемоизации ###
        print(f'{my_number}! = {factorial_memoize_func(my_number)}')

    # В случае ошибки ввода или отсутствия данных программа будет работать
    # с произвольными значениями, заданными по умолчанию для функции
    except ValueError:
        print('\nВведенные пользовательские данные не позволяют '
            'адекватно работать алгоритму программы.\n'
            'Пример работы функции с произвольными значениями:\n')

        random_number = factorial_cycle_func.__defaults__[0]
        print('Случайно сгенерированное число:\n\t', random_number)

        # Запуск функции с произвольными данными
        print(f'{random_number}! = {factorial_cycle_func(random_number)}')